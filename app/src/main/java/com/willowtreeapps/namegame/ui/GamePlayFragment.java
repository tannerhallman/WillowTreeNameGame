package com.willowtreeapps.namegame.ui;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.view.animation.Interpolator;import android.view.animation.OvershootInterpolator;import android.widget.FrameLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import com.squareup.picasso.Callback;import com.squareup.picasso.Picasso;import com.willowtreeapps.namegame.R;import com.willowtreeapps.namegame.core.ListRandomizer;import com.willowtreeapps.namegame.core.NameGameApplication;import com.willowtreeapps.namegame.network.api.Person;import com.willowtreeapps.namegame.network.api.PersonRepository;import com.willowtreeapps.namegame.util.CircleBorderTransform;import com.willowtreeapps.namegame.util.GameSession;import com.willowtreeapps.namegame.util.Ui;import java.text.DecimalFormat;import java.text.NumberFormat;import java.util.ArrayList;import java.util.List;import java.util.Stack;import javax.inject.Inject;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.Optional;public class GamePlayFragment extends Fragment {    private static final Interpolator OVERSHOOT = new OvershootInterpolator();    private static final String TAG = "Game Tag";    // Dagger injections    @Inject ListRandomizer listRandomizer;    @Inject Picasso picasso;    @Inject PersonRepository repo;    @BindView(R.id.title) TextView title;    @BindView(R.id.question) TextView question;    // contains 2 horizontal linear layouts [1 toprow and 1 bottomrow]    @BindView(R.id.face_container) LinearLayout faceContainer;    @BindView(R.id.topRow) LinearLayout topRow;    @Nullable @BindView(R.id.bottomrow) LinearLayout bottomRow;    @BindView(R.id.score) TextView score;    @BindView(R.id.averageTime) TextView averageTime;    // Views for the Reverse Game mode    @BindView(R.id.reverseFace) ImageView reverseFace;    private final int classicFaceCount = 5;    private final int reverseFaceCount = 1;    //The amount of faces that are displayed (Should correspond to the amount of FrameLayouts)    private int faceCount;    // A list of the FrameLayouts that contain progress bar, imageview and textview    private List<FrameLayout> frames;    // A list of the allPersons that are currently displayed    private List<Person> personsInQuestion; //used in all modes    // A list of *all* of the allPersons that have been loaded by the API    private List<Person> allPersons; // used in all modes    private List<Person> mattOnly; //used for matt mode    private List<TextView> names; // used for reverse mode    // A state of the game    private GameSession gameSession;    // the size of the images    int imageSize;    private NumberFormat formatter;    private Bundle savedState;    private final String savedGamePlayString = "savedGame";    // Create a reference to the listener so that it can be used to unsubscribe in onDestory    private PersonRepository.Listener personRepoListener = new PersonRepository.Listener() {        @Override        public void onLoadFinished(@NonNull List<Person> people) {            GamePlayFragment.this.allPersons = people;            if (savedState == null) {                loadNewContent(false);            } else {                //Log.i(TAG, "person repo listener got called but savedState = null");            }        }        @Override        public void onError(@NonNull Throwable error) {            Log.e(TAG, error.getMessage());        }    };    // TODO: Fix the restoreSession and saveState() for Matt, Reverse, Custom    @Override    public void onCreate(@Nullable Bundle savedInstanceState) {        //Log.i(TAG, "onCreate Called");        super.onCreate(savedInstanceState);        NameGameApplication.get(getActivity()).getComponent().inject(this);        frames = new ArrayList<>(faceCount);        personsInQuestion = new ArrayList<>(faceCount);        allPersons = new ArrayList<>();        formatter = new DecimalFormat("#0.00");        savedState = null;        if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.REVERSE){            imageSize = (int) Ui.convertDpToPixel(300, getContext());        } else {            imageSize = (int) Ui.convertDpToPixel(100, getContext());        }        if (savedInstanceState == null) {            //Log.i(TAG, "savedInstanceState was null");            repo.register(personRepoListener);        } else {            //Log.i(TAG, "savedInstanceState was not null");        }        //Log.i(TAG, getActivity().getSupportFragmentManager().getFragments().toString());    }    @Override    public void onActivityCreated(@Nullable Bundle savedInstanceState) {        super.onActivityCreated(savedInstanceState);        if (savedInstanceState != null) {            //Log.i(TAG, "onActivityCreated() restore true ");            //restoreState(savedInstanceState);        } else {            //Log.i(TAG, "onActivityCreated() restore false ");        }    }    @Nullable    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {        //Log.i(TAG, "onCreateViewCalled & restoring state");        View view = inflater.inflate(R.layout.game_play_fragment, container, false);        ButterKnife.bind(this, view);        /* If the Fragment was destroyed inbetween (screen rotation), we need to recover the savedState first */        /* However, if it was not, it stays in the instance from the last onDestroyView() and we don't want to overwrite it */        if (savedInstanceState != null && savedState == null) {            savedState = savedInstanceState.getBundle(savedGamePlayString);        }        if (savedState != null) {            restoreState(savedInstanceState);        }        savedState = null;        return view;    }    /**     * A method to setup parameters after the views have loaded     *     * @param view     * @param savedInstanceState     */    @Override    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {        Log.i(TAG, "onViewCreated called");        if (savedInstanceState == null) {            NameGameActivity.GameMode mode = NameGameActivity.getGameMode();            Log.i(TAG, "savedInstanceState was null");            title.setText(getTitleText(mode));            faceCount = classicFaceCount;            if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.MATT) {                mattOnly = new ArrayList<>();            } else if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.REVERSE ||                    NameGameActivity.getGameMode() == NameGameActivity.GameMode.INVINCIBLE) {                names = new ArrayList<>();            }            Log.i(TAG, "Starting a new game session from onviewCreated");            gameSession = new GameSession(faceCount, this);            Log.i(TAG, "Instantiating the timer from onviewcreated");            gameSession.instantiateTimer(gameSession.getCountDownDuration());            setupTopRow();            if (bottomRow != null) setUpBottmRow();        } else {            // restore savedState            //Log.i(TAG, "savedInstanceState was not null & Restoring state form onViewCreated call");        }    }    /**     * A method to initially setup the rows of ImageViews and Progressbars so that     * images can be loaded into them.     */    private void setupTopRow() {        try {            int toprowcount = topRow.getChildCount();            //Log.i(TAG, "Top row count" + Integer.toString(toprowcount));            for (int j = 0; j < toprowcount; j++) {                FrameLayout frame = (FrameLayout) topRow.getChildAt(j);                //frame.setTag("FrameLayout" + Integer.toString(j));                ImageView face = (ImageView) frame.getChildAt(0);                //face.setTag("face" + Integer.toString(j));                //face.setVisibility(View.VISIBLE);                if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.REVERSE ||                        NameGameActivity.getGameMode() == NameGameActivity.GameMode.INVINCIBLE){                    frame.getChildAt(2).setOnClickListener(new MasterClickListener());                }                else {                    face.setOnClickListener(new MasterClickListener());                }                ProgressBar progressBar = (ProgressBar) frame.getChildAt(1);                progressBar.setMinimumHeight(imageSize);                progressBar.setMinimumWidth(imageSize);                //progressBar.setVisibility(View.VISIBLE);                frames.add(frame);                face.setScaleX(0);                face.setScaleY(0);            }        } catch (Exception e) {            e.printStackTrace();        }    }    @Optional    private void setUpBottmRow() {        try {            int bottomrowcount = bottomRow.getChildCount();            for (int j = 0; j < bottomrowcount; j++) {                FrameLayout frame = (FrameLayout) bottomRow.getChildAt(j);                ImageView face = (ImageView) frame.getChildAt(0);                //face.setVisibility(View.VISIBLE);                if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.REVERSE ||                        NameGameActivity.getGameMode() == NameGameActivity.GameMode.INVINCIBLE){                    frame.getChildAt(2).setOnClickListener(new MasterClickListener());                }                else {                    face.setOnClickListener(new MasterClickListener());                }                //ProgressBar progressBar = (ProgressBar) frame.getChildAt(1);                //progressBar.setVisibility(View.VISIBLE);                frames.add(frame);                face.setScaleX(0);                face.setScaleY(0);            }        } catch (Exception e) {            e.printStackTrace();        }    }    @Optional    private void setUpSingleImage() {        try {                reverseFace.setVisibility(View.VISIBLE);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * A method that returns the amount of faces that need to be loaded.     *     * @param mode     * @return the amount of faces     */    private int getFaceCount(NameGameActivity.GameMode mode) {        switch (mode) {            case CLASSIC:                return classicFaceCount;            case MATT:                return classicFaceCount;            case REVERSE:                return reverseFaceCount;            case INVINCIBLE:                return classicFaceCount;            default:                return classicFaceCount;        }    }    /**     * A method that returns the String of the gamemode     * to set for the title     *     * @param mode     * @return     */    private String getTitleText(NameGameActivity.GameMode mode) {        switch (mode) {            case CLASSIC:                return getResources().getString(R.string.gameModeClassic);            case MATT:                return getResources().getString(R.string.gameModeMatt);            case REVERSE:                return getResources().getString(R.string.gameModeReverse);            case INVINCIBLE:                return getResources().getString(R.string.gameModeInvincible);            default:                return "Willow Tree Name Game";        }    }    /**     * A helper method that saves the state of the fragment for config changes     *     * @return the bundle to be saved     */    private Bundle saveState() { /* called either from onDestroyView() or onSaveInstanceState() */        //Log.i(TAG, "saveState() called ");        Bundle state = new Bundle();        state.putDouble("averageTime", gameSession.getAverageTime());        state.putDouble("totalTime", gameSession.getTotalTimeSeconds());        state.putInt("questionsAsked", gameSession.getQuestionsAsked());        state.putInt("questionsCorrect", gameSession.getQuestionsCorrect());        state.putLong("countDownDuration", gameSession.getCountDownDuration());        state.putLong("millisUntilFinished", gameSession.getMillisUntilFinished());        state.putInt("currentRando", gameSession.getCurrentRando());        state.putInt("fadeGap", gameSession.getFadeGap());        if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.MATT) {            // save all the persons            ArrayList<String> mattNames = new ArrayList<>(mattOnly.size());            ArrayList<String> mattUrls = new ArrayList<>(mattOnly.size());            for (Person p : mattOnly) {                mattNames.add(p.getName());                mattUrls.add(p.getUrl());            }            state.putStringArrayList("mattNames", mattNames);            state.putStringArrayList("mattUrls", mattUrls);        }        Stack<Integer> stackToSave = gameSession.getFacesNotYetFaded();        int[] arrayOfStack = new int[stackToSave.size()];        // want to maintain order so that loading on stack is natural        for (int x = arrayOfStack.length - 1; x >= 0; x--) {            arrayOfStack[x] = stackToSave.pop();        }        state.putIntArray("arrayOfStack", arrayOfStack);        state.putIntegerArrayList("facesAlreadyFaded", gameSession.getFacesAlreadyFaded());        // save all the persons        ArrayList<String> personsNames = new ArrayList<>(allPersons.size());        ArrayList<String> personsUrls = new ArrayList<>(allPersons.size());        for (Person p : allPersons) {            personsNames.add(p.getName());            personsUrls.add(p.getUrl());        }        state.putStringArrayList("personsNames", personsNames);        state.putStringArrayList("personsUrls", personsUrls);        // save the current chosen persons        ArrayList<String> personsInQuestionNames = new ArrayList<>(personsInQuestion.size());        ArrayList<String> personsInQuestionUrls = new ArrayList<>(personsInQuestion.size());        for (Person p : personsInQuestion) {            personsInQuestionNames.add(p.getName());            personsInQuestionUrls.add(p.getUrl());        }        state.putStringArrayList("personsInQuestionNames", personsInQuestionNames);        state.putStringArrayList("personsInQuestionUrls", personsInQuestionUrls);        return state;    }    /**     * A helper method that reinstates the fragments vars and views     *     * @param savedInstanceState the state to be recreated     */    private void restoreState(Bundle savedInstanceState) {        /* If the Fragment was destroyed inbetween (screen rotation), we need to recover the savedState first */        /* However, if it was not, it stays in the instance from the last onDestroyView() and we don't want to overwrite it */        if (savedInstanceState != null && savedState == null) {            //Log.i(TAG, "restoreState() savedState and savedInstanceState == null");            savedState = savedInstanceState.getBundle(savedGamePlayString);        }        if (savedState != null) {            //Log.i(TAG, "restoreState() getting components and restoring them ");            NameGameActivity.GameMode mode = NameGameActivity.getGameMode();            if (title != null) title.setText(getTitleText(mode));            faceCount = getFaceCount(mode);            //Log.i(TAG, "Starting a new game session from restoreState");            gameSession = new GameSession(faceCount, this);            gameSession.setAverageTime(savedState.getDouble("averageTime"));            gameSession.setTotalTimeSeconds(savedState.getDouble("totalTime"));            gameSession.setQuestionsAsked(savedState.getInt("questionsAsked"));            gameSession.setQuestionsCorrect(savedState.getInt("questionsCorrect"));            gameSession.setCountDownDuration(savedState.getLong("countDownDuration"));            gameSession.setMillisUntilFinished(savedState.getLong("millisUntilFinished"));            gameSession.setCurrentRando(savedState.getInt("currentRando"));            gameSession.setFadeGap(savedState.getInt("fadeGap"));            if (NameGameActivity.getGameMode() == NameGameActivity.GameMode.MATT) {                // save all the persons                ArrayList<String> mattNames = savedState.getStringArrayList("mattNames");                ArrayList<String> mattUrls = savedState.getStringArrayList("mattUrls");                mattOnly = new ArrayList<>();                for (int n = 0; n < mattNames.size(); n++) {                    mattOnly.add(new Person(mattNames.get(n),                            mattUrls.get(n)));                }            }            Stack<Integer> stackToLoad = new Stack<>();            int[] arrayOfStack = savedState.getIntArray("arrayOfStack");            // loading onto stack is natural because of the way stack was unloaded            for (int x = arrayOfStack.length - 1; x >= 0; x--) {                stackToLoad.push(arrayOfStack[x]);            }            Log.i(TAG, "setting stack from restore" + stackToLoad.toString());            gameSession.setFacesNotYetFaded(stackToLoad);            gameSession.setFacesAlreadyFaded(savedState.getIntegerArrayList("facesAlreadyFaded"));            ArrayList<String> personsNames = savedState.getStringArrayList("personsNames");            ArrayList<String> personsUrls = savedState.getStringArrayList("personsUrls");            List<Person> allPersons = new ArrayList<>();            for (int n = 0; n < personsNames.size(); n++) {                allPersons.add(new Person(personsNames.get(n),                        personsUrls.get(n)));            }            setAllPersons(allPersons);            // restore the current chosen faces            ArrayList<String> personsInQuestionNames = savedState.getStringArrayList("personsInQuestionNames");            ArrayList<String> personsInQuestionUrls = savedState.getStringArrayList("personsInQuestionUrls");            List<Person> personsInQuestion = new ArrayList<>();            for (int n = 0; n < personsInQuestionNames.size(); n++) {                personsInQuestion.add(new Person(personsInQuestionNames.get(n),                        personsInQuestionUrls.get(n)));            }            //Log.i(TAG, personsInQuestion.toString());            setPersonsInQuestion(personsInQuestion);            Log.i(TAG, "Instantiating timer from resotreSTate");            gameSession.instantiateTimer(gameSession.getMillisUntilFinished());            loadNewContent(true);        }        // release the savedState        savedState = null;    }    /**     * A method that is used to load new content into imageviews and     * load new questions     */    public void loadNewContent(Boolean restoringState) {        //Log.i(TAG,  "loadNewContent() with state " + restoringState.toString());        if (!restoringState) {            personsInQuestion.clear();        }        try {            averageTime.setText(formatter.format(gameSession.getAverageTime()));            score.setText(Integer.toString(gameSession.getQuestionsCorrect()) + " / "                    + Integer.toString(gameSession.getQuestionsAsked()));        } catch (Exception e) {            Log.e(TAG, e.getStackTrace().toString());        }        switch (NameGameActivity.getGameMode()) {            case CLASSIC:                if (!restoringState)                    personsInQuestion = listRandomizer.pickN(allPersons, faceCount);                frames.clear();                setupTopRow();                if (bottomRow != null) setUpBottmRow();                setImages(frames, personsInQuestion);                if (!restoringState) { // restoringState = false                    gameSession.resetSessionState();                } else { // restoringState = true                    gameSession.restoreSessionState();                }                //Log.i(TAG, "Person in question " + personsInQuestion.get(gameSession.getCurrentRando()).getName());                question.setText("Who is " + personsInQuestion.get(gameSession.getCurrentRando()).getName() + "?");                break;            case MATT:                for (Person p : allPersons) {                    if (p.getName().substring(0, 3).equalsIgnoreCase("Mat"))                        mattOnly.add(p);                }                if (!restoringState) personsInQuestion = listRandomizer.pickN(mattOnly, faceCount);                frames.clear();                setupTopRow();                if (bottomRow != null) setUpBottmRow();                setImages(frames, personsInQuestion);                if (!restoringState) { // restoringState = false                    gameSession.resetSessionState();                } else { // restoringState = true                    gameSession.restoreSessionState();                }                //Log.i(TAG, "Person in question " + personsInQuestion.get(gameSession.getCurrentRando()).getName());                question.setText("Who is " + personsInQuestion.get(gameSession.getCurrentRando()).getName() + "?");                break;            case REVERSE:                if (!restoringState)                    personsInQuestion = listRandomizer.pickN(allPersons, faceCount);                frames.clear();                setUpSingleImage();                setSingleImage(reverseFace, personsInQuestion.get(gameSession.getCurrentRando()));                setupTopRow();                if (bottomRow != null) setUpBottmRow();                setTextViews(frames, personsInQuestion);                if (!restoringState) { // restoringState = false                    gameSession.resetSessionState();                } else { // restoringState = true                    gameSession.restoreSessionState();                }                //Log.i(TAG, "Person in question " + personsInQuestion.get(gameSession.getCurrentRando()).getName());                //question.setText("Who is " + personsInQuestion.get(gameSession.getCurrentRando()).getName() + "?");                //Log.i(TAG, "REVERSE NOT YET IMPELMTEND");                break;            case INVINCIBLE:                if (!restoringState)                    personsInQuestion = listRandomizer.pickN(allPersons, 1);                frames.clear();                setUpSingleImage();                setSingleImage(reverseFace, personsInQuestion.get(gameSession.getCurrentRando()));                setupTopRow();                if (bottomRow != null) setUpBottmRow();                setTextViews(frames, personsInQuestion);                if (!restoringState) { // restoringState = false                    gameSession.resetSessionState();                } else { // restoringState = true                    gameSession.restoreSessionState();                }                //Log.i(TAG, "Person in question " + personsInQuestion.get(gameSession.getCurrentRando()).getName());                //question.setText("Who is " + personsInQuestion.get(gameSession.getCurrentRando()).getName() + "?");                //Log.i(TAG, "REVERSE NOT YET IMPELMTEND");                break;            default:                //Log.e(TAG, "Have not implemented any other game types");                break;        }    }    /**     * A method to handle when a person is selected     *     * @param view   The view that was selected     * @param person The person that was selected     */    private void onPersonSelected(@NonNull View view, @NonNull Person person) {        if (person.getName().equals(personsInQuestion.get(gameSession.getCurrentRando()).getName())) {            gameSession.setQuestionsCorrect(gameSession.getQuestionsCorrect() + 1);            Toast.makeText(getActivity(), "Correct!", Toast.LENGTH_SHORT).show();        } else {            //Log.i(TAG, "selected the wrong person " + person.getName());            Toast.makeText(getActivity(), "Incorrect!", Toast.LENGTH_SHORT).show();        }        incrementQuestionsAsked();        gameSession.cancelTimer();        gameSession.updateAverage(gameSession.getTimeSpent());        loadNewContent(false);    }    private void incrementQuestionsAsked(){        gameSession.setQuestionsAsked(gameSession.getQuestionsAsked() + 1);    }    /**     * A method to handle when the timer has runout.     */    public void outOfTime() {        try {            Toast.makeText(getActivity(), "Out of time!", Toast.LENGTH_SHORT).show();        } catch (Exception e) {            e.printStackTrace();        }        gameSession.cancelTimer();        gameSession.updateAverage(gameSession.getCountDownDuration() / 1000);        incrementQuestionsAsked();        loadNewContent(false);    }    /**     * A method for setting a single Image     */    private void setSingleImage(final ImageView iv, Person person){        try {            //Log.i(TAG, "image size " + Integer.toString(imageSize));            picasso.load(person.getUrl())                    .resize(imageSize, imageSize)                    .transform(new CircleBorderTransform())                    .into(iv, new Callback() {                        @Override                        public void onSuccess() {                            iv.setVisibility(View.VISIBLE);                        }                        @Override                        public void onError() {                            iv.setBackgroundResource(R.drawable.ic_face_white_48dp);                            Log.e(TAG, "Picasso error loading image");                        }                    });        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * A method for setting the images from allPersons into the imageviews     */    private void setImages(List<FrameLayout> frames, List<Person> people) {        //Log.i(TAG, "image size " + Integer.toString(imageSize));        for (int i = 0; i < frames.size(); i++) {            final FrameLayout frame = frames.get(i);            // In FrameLayout:            // index 0 = ImageView,            // index 1 = ProgressView,            // index 2 = TextView            if (frame.getChildAt(0) != null) {                if (frame.getChildAt(0) instanceof ImageView) {                    final ImageView face = (ImageView) frame.getChildAt(0);                    if (frame.getChildAt(1) != null) {                        if (frame.getChildAt(1) instanceof ProgressBar) {                            final ProgressBar progressBar = (ProgressBar) frame.getChildAt(1);                            progressBar.setVisibility(View.VISIBLE);                            picasso.load(people.get(i).getUrl())                                    .resize(imageSize, imageSize)                                    .transform(new CircleBorderTransform())                                    .into(face, new Callback() {                                        @Override                                        public void onSuccess() {                                            progressBar.setVisibility(View.GONE);                                            face.setVisibility(View.VISIBLE);                                        }                                        @Override                                        public void onError() {                                            progressBar.setVisibility(View.INVISIBLE);                                            face.setBackgroundResource(R.drawable.ic_face_white_48dp);                                            Log.e(TAG, "Picasso error loading image");                                        }                                    });                        }                    }                }            }            if (frame.getChildAt(2) != null) { // make sure textview is invisible                if (frame.getChildAt(2) instanceof TextView) {                    final TextView tv = (TextView) frame.getChildAt(2);                    tv.setVisibility(View.INVISIBLE);                }            }            //Log.i(TAG, "size of People " + people.size());            //Log.i(TAG, "value of i " + Integer.toString(i));            //Log.i(TAG, "Loading (" + Integer.toString(i) + ")" + people.get(i).getName().toString());        }        animateFacesIn();        gameSession.startTimer();    }    /**     * A method to set the textviews for the reverse     *  game mode     */    private void setTextViews(List<FrameLayout> frames, List<Person> people) {        for (int i = 0; i < frames.size(); i++) {            final FrameLayout frame = frames.get(i);            // In FrameLayout: index 0 = ImageView, index 1 = ProgressView, index 2 = TextView            if (frame.getChildAt(0) != null){                if (frame.getChildAt(0) instanceof ImageView) {                    final ImageView face = (ImageView) frame.getChildAt(0);                    face.setVisibility(View.INVISIBLE);                }            }            if (frame.getChildAt(1) != null){                if (frame.getChildAt(1) instanceof ProgressBar) {                    final ProgressBar progressBar = (ProgressBar) frame.getChildAt(1);                    progressBar.setVisibility(View.INVISIBLE);                }            }            if (frame.getChildAt(2) != null) { // make sure textview is invisible                if (frame.getChildAt(2) instanceof TextView) {                    final TextView tv = (TextView) frame.getChildAt(2);                    tv.setText(people.get(i).getName());                    tv.setVisibility(View.VISIBLE);                }            }        }    }    /**     * A method to animate the faces into view     */    private void animateFacesIn() {        title.animate().alpha(1).start();        for (int i = 0; i < frames.size(); i++) {            FrameLayout frame = frames.get(i);            ImageView face = (ImageView) frame.getChildAt(0);            face.animate().scaleX(1).scaleY(1).setStartDelay(800 + 120 * i).setInterpolator(OVERSHOOT).start();        }        faceContainer.setClickable(true);    }    /**     * A custom click Listener class that handles clicks     * for any of the ImageViews     */    private class MasterClickListener implements View.OnClickListener {        @Override        public void onClick(View v) {            switch (v.getId()) {                case R.id.face1:                case R.id.name1:                    onPersonSelected(v, personsInQuestion.get(0));                    break;                case R.id.face2:                case R.id.name2:                    onPersonSelected(v, personsInQuestion.get(1));                    break;                case R.id.face3:                case R.id.name3:                    onPersonSelected(v, personsInQuestion.get(2));                    break;                case R.id.face4:                case R.id.name4:                    onPersonSelected(v, personsInQuestion.get(3));                    break;                case R.id.face5:                case R.id.name5:                    onPersonSelected(v, personsInQuestion.get(4));                    break;                default:                    Log.i(TAG, "Nothing of value clicked");                    break;            }        }    }    /**     * A method that calls saveState() during the     * destruction of the fragment (muhahah)     *     * @param outState     */    @Override    public void onSaveInstanceState(Bundle outState) {        super.onSaveInstanceState(outState);        //Log.i(TAG, "onSaveInstanceState called");        /* If onDestroyView() is called first, we can use the previously savedState but we can't call saveState() anymore */        /* If onSaveInstanceState() is called first, we don't have savedState, so we need to call saveState() */        /* => (?:) operator inevitable! */        outState.putBundle(savedGamePlayString, (savedState != null) ? savedState : saveState());    }    /**     * A method that attempts to saveState()     */    @Override    public void onDestroyView() {        //Log.i(TAG, "onDestroyView called... calling saveState()");        savedState = saveState();        super.onDestroyView();    }    /**     * A method that releases any listeners and tasks that are     * running     */    @Override    public void onDestroy() {        //Log.i(TAG, "OnDestory Called");        repo.unregister(personRepoListener);        gameSession.cancelTimer();        super.onDestroy();    }    // -------------- The getter and setter methods --------------    public List<FrameLayout> getFrames() {        return frames;    }    public void setPersonsInQuestion(List<Person> personsInQuestion) {        this.personsInQuestion = personsInQuestion;    }    public void setAllPersons(List<Person> allPersons) {        this.allPersons = allPersons;    }}